<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbit Translator</title>
    
    <!-- External Icons & Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #070707;
            --accent-color: #22c55e;
            --text-color: #ffffff;
            --surface-color: #1a1a1a;
            --border-color: #333;
        }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- CAPTION BAR --- */
        #caption-bar {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        #original-text {
            font-size: 14px;
            color: #888;
            margin-bottom: 8px;
            min-height: 1em;
        }

        #translated-text {
            font-size: 24px;
            color: var(--accent-color);
            font-weight: 600;
            text-shadow: 0 0 20px rgba(102, 255, 0, 0.3);
        }

        .interim {
            opacity: 0.5;
            font-style: italic;
        }

        /* --- CONTROLS --- */
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
        }

        .btn {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: var(--accent-color);
            background: rgba(102, 255, 0, 0.05);
        }

        .btn.recording {
            background: var(--accent-color);
            color: black;
            border-color: var(--accent-color);
            box-shadow: 0 0 20px rgba(102, 255, 0, 0.4);
        }

        #status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        /* --- SETTINGS PILL --- */
        .settings-pill {
            position: absolute;
            top: 20px;
            display: flex;
            gap: 10px;
            background: var(--surface-color);
            padding: 8px 16px;
            border-radius: 50px;
            border: 1px solid var(--border-color);
        }

        select {
            background: transparent;
            color: white;
            border: none;
            outline: none;
            font-size: 13px;
            cursor: pointer;
        }

        .header-logo {
            position: absolute;
            top: 20px;
            left: 30px;
            height: 35px;
        }

        .header-logo img {
            height: 100%;
        }
    </style>
</head>
<body>

    <div class="header-logo">
        <img src="/images/eburon-logo.svg" alt="Orbit Logo">
    </div>

    <div class="settings-pill">
        <div style="display:flex; align-items:center; gap:8px;">
            <i class="fa-solid fa-globe" style="color:var(--accent-color)"></i>
            <select id="target-language" title="Select target language">
                <option value="Tagalog-English mix (Taglish)">Taglish</option>
                <option value="Spanish">Spanish</option>
                <option value="French">French</option>
                <option value="German">German</option>
                <option value="Japanese">Japanese</option>
                <option value="Chinese">Chinese</option>
            </select>
        </div>
        <div style="width:1px; background:#333; margin:0 5px;"></div>
        <div style="display:flex; align-items:center; gap:8px;">
            <i class="fa-solid fa-microphone" id="mic-icon"></i>
            <select id="mic-select" title="Select microphone device">
                <option>Loading mics...</option>
            </select>
        </div>
    </div>

    <div class="controls">
        <button id="start-btn" class="btn">
            <i class="fa-solid fa-play"></i> START TRANSLATOR
        </button>
    </div>

    <div id="status">Status: Idle</div>

    <div id="caption-bar">
        <div id="original-text">Orbit is listening...</div>
        <div id="translated-text">Translation will appear here...</div>
    </div>

    <script type="module">
        import { createClient as createDeepgramClient, LiveTranscriptionEvents } from 'https://esm.sh/@deepgram/sdk';

        let isRecording = false;
        let deepgramConnection = null;
        let mediaRecorder = null;
        let activeStream = null;
        
        // Audio Queue Management
        let audioQueue = [];
        let isPlaying = false;

        const startBtn = document.getElementById('start-btn');
        const originalText = document.getElementById('original-text');
        const translatedText = document.getElementById('translated-text');
        const statusEl = document.getElementById('status');
        const targetLangSelect = document.getElementById('target-language');
        const micSelect = document.getElementById('mic-select');

        // Initial setup: List microphones
        async function setupMics() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const mics = devices.filter(d => d.kind === 'audioinput');
                
                micSelect.innerHTML = mics.map(m => 
                    `<option value="${m.deviceId}">${m.label || 'Microphone ' + m.deviceId.slice(0,5)}</option>`
                ).join('');
            } catch (err) {
                console.error("Mic access denied", err);
                micSelect.innerHTML = '<option>Permission Denied</option>';
            }
        }
        setupMics();

        startBtn.onclick = () => {
            if (isRecording) {
                stopAll();
            } else {
                startAll();
            }
        };

        async function startAll() {
            isRecording = true;
            startBtn.classList.add('recording');
            startBtn.innerHTML = '<i class="fa-solid fa-stop"></i> STOP TRANSLATOR';
            statusEl.innerText = 'Status: Connecting...';
            audioQueue = []; // Clear queue

            try {
                const tokenResp = await fetch('/api/deepgram/token');
                const { key } = await tokenResp.json();
                
                const transcription = createTranscriptionClient(key);
                
                activeStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { deviceId: { exact: micSelect.value } } 
                });

                transcriptionConnection = transcription.listen.live({
                    model: 'nova-2',
                    language: 'en',
                    smart_format: true,
                    interim_results: true,
                    utterance_end_ms: 1000,
                    vad_events: true
                });

                transcriptionConnection.on(LiveTranscriptionEvents.Open, () => {
                    statusEl.innerText = 'Status: Listening...';
                    
                    mediaRecorder = new MediaRecorder(activeStream);
                    mediaRecorder.addEventListener('dataavailable', event => {
                        if (event.data.size > 0 && transcriptionConnection.getReadyState() === 1) {
                            transcriptionConnection.send(event.data);
                        }
                    });
                    mediaRecorder.start(250);
                });

                transcriptionConnection.on(LiveTranscriptionEvents.Transcript, async (data) => {
                    const alt = data.channel?.alternatives?.[0];
                    if (alt && alt.transcript) {
                        const text = alt.transcript;
                        if (data.is_final) {
                            originalText.innerText = text;
                            handleStreamingTranslation(text);
                        } else {
                            originalText.innerHTML = `<span class="interim">${text}</span>`;
                        }
                    }
                });

                transcriptionConnection.on(LiveTranscriptionEvents.Error, (err) => {
                    console.error("Transcription Error", err);
                    statusEl.innerText = 'Status: Error';
                });

            } catch (err) {
                console.error(err);
                statusEl.innerText = 'Status: Connection Failed';
                stopAll();
            }
        }

        async function handleStreamingTranslation(text) {
            statusEl.innerText = 'Status: Translating...';
            const targetLang = targetLangSelect.value;
            translatedText.innerText = ""; // Clear for new stream

            try {
                const response = await fetch('/api/orbit/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, targetLang })
                });

                if (!response.ok) throw new Error("Translation failed");
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";
                let sentenceBuffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    
                    // Simple parsing of NDJSON output
                    const lines = (buffer + chunk).split('\n');
                    buffer = lines.pop(); // Keep incomplete line

                    for (const line of lines) {
                        if (!line.trim()) continue;
                        try {
                            const json = JSON.parse(line);
                            if (json.message && json.message.content) {
                                const content = json.message.content;
                                translatedText.innerText += content;
                                
                                sentenceBuffer += content;
                                
                                // Sentence breaking logic (simple)
                                if (/[.!?]/.test(content) && sentenceBuffer.length > 5) {
                                    handleSynthesis(sentenceBuffer.trim());
                                    sentenceBuffer = "";
                                }
                            }
                        } catch (e) {
                            // Ignore parse errors (partial JSON)
                        }
                    }
                }
                
                // Process remaining buffer
                if (sentenceBuffer.trim().length > 0) {
                    handleSynthesis(sentenceBuffer.trim());
                }

            } catch (err) {
                console.error(err);
                statusEl.innerText = 'Status: Translation Error';
            }
        }

        async function handleSynthesis(text) {
            const payload = constructSynthesisPayload(text);
            if (!payload) return; // Validation failed

            console.log("Queuing Audio for verified payload:", payload);

            try {
                const synthesisResp = await fetch('/api/orbit/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!synthesisResp.ok) throw new Error("Synthesis failed");
                
                const blob = await synthesisResp.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                
                // Add to queue
                audioQueue.push(audio);
                playQueue();

            } catch (err) {
                console.error(err);
            }
        }

        /**
         * Robust JSON Construction & Validation
         * Ensures text is valid and structures the payload correctly.
         */
        function constructSynthesisPayload(text) {
            // 1. Validate Input
            if (typeof text !== 'string') {
                console.warn("Synthesis Validation Failed: Input is not a string");
                return null;
            }
            
            const trimmed = text.trim();
            if (trimmed.length === 0) {
                console.warn("Synthesis Validation Failed: Input is empty");
                return null;
            }

            // 2. Construct Payload
            return { 
                text: trimmed
            };
        }

        async function playQueue() {
            if (isPlaying || audioQueue.length === 0) return;
            
            isPlaying = true;
            const audio = audioQueue.shift();
            statusEl.innerText = 'Status: Speaking...';
            
            audio.onended = () => {
                isPlaying = false;
                if (audioQueue.length === 0) {
                     statusEl.innerText = 'Status: Listening...';
                }
                playQueue(); // Play next
            };
            
            await audio.play();
        }

        function stopAll() {
            isRecording = false;
            startBtn.classList.remove('recording');
            startBtn.innerHTML = '<i class="fa-solid fa-play"></i> START TRANSLATOR';
            statusEl.innerText = 'Status: Idle';
            audioQueue = [];
            isPlaying = false;

            if (transcriptionConnection) transcriptionConnection.requestClose();
            if (mediaRecorder) mediaRecorder.stop();
            if (activeStream) activeStream.getTracks().forEach(t => t.stop());
        }
    </script>
</body>
</html>
